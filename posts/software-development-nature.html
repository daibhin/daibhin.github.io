<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Revision Notes: The Nature of Software Development</title><meta name="next-head-count" content="3"/><link rel="preload" href="/personal-site/_next/static/css/d13585b830d0ddc5.css" as="style"/><link rel="stylesheet" href="/personal-site/_next/static/css/d13585b830d0ddc5.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/personal-site/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/personal-site/_next/static/chunks/webpack-54ebfc5766bb1850.js" defer=""></script><script src="/personal-site/_next/static/chunks/framework-fc97f3f1282ce3ed.js" defer=""></script><script src="/personal-site/_next/static/chunks/main-f4ae3437c92c1efc.js" defer=""></script><script src="/personal-site/_next/static/chunks/pages/_app-f55443f2448c8e66.js" defer=""></script><script src="/personal-site/_next/static/chunks/pages/posts/software-development-nature-ae727b251f0f893b.js" defer=""></script><script src="/personal-site/_next/static/5XjfA1Y6gVshClxRW5E3Q/_buildManifest.js" defer=""></script><script src="/personal-site/_next/static/5XjfA1Y6gVshClxRW5E3Q/_ssgManifest.js" defer=""></script><script src="/personal-site/_next/static/5XjfA1Y6gVshClxRW5E3Q/_middlewareManifest.js" defer=""></script></head><body><div id="__next">
<!-- --><p><strong>The philosophy:</strong></p>
<!-- --><p>We want <!-- --><strong>value</strong>.
Teams must be given responsibility for creating value.
They must be <!-- --><strong>guided</strong> to understand needs and time constraints.
These teams must be <!-- --><strong>organised</strong>.
We organise around features.
We <!-- --><strong>plan</strong> by selecting the features we need, and in what order.
We <!-- --><strong>build</strong> feature by feature to ensure frequent delivery of value.
This ensures that we can see how things are progressing, early and often.
<!-- --><strong>Slicing</strong> features down enhances this.
A capable product can be enhanced and grown.
You must always remain ready to ship.
We must ensure <!-- --><strong>quality</strong> as we go to ensure value remains continuous, sustainable and indefinite.<!-- --></p>
<!-- --><h4>Value</h4>
<!-- --><ul>
<!-- --><li>Value is what we want. * Features (minimum marketable features) deliver value.</li>
<!-- --><li>Work incrementally for each new feature. _ Value is only achieved once software
is shipped. Value must be delivered early. _ Features: Everyone may want something
different, but no one wants everything. _ Ship early, ship often. _ Focus on high
value, low cost features first. The next features mightn&#x27;t be worth the time and
money once the time comes to make them (so don&#x27;t!).</li>
<!-- --></ul>
<!-- --><h4>Guiding</h4>
<!-- --><ul>
<!-- --><li>Don&#x27;t follow the Analysis, Design, Coding, Testing in series method. Analysis doesn&#x27;t
give insight to Design or Coding. Testing at the end leaves no time to readjust.</li>
<!-- --><li>Monolith projects are bad. _ You&#x27;ll waste time planning for things you&#x27;ll never
complete by the deadline = Wasted work! _ Multiple releases are easier manage and
show value sooner. * Projects that deliver feature by feature are more predictable.</li>
<!-- --><li>You get a better sense of the projects cadence.</li>
<!-- --></ul>
<!-- --><h4>Organizing</h4>
<!-- --><ul>
<!-- --><li>If teams are organized by skills-set, scheduling and delays will arise during handoffs
between teams. _ Organize by &#x27;Feature Teams&#x27;, each with all the necessary skills
to build the <!-- --><strong>entire</strong> feature. _ If you don&#x27;t have enough specialists for all your
teams, just make do. Assigning the best to the most important features. Creates a
training/learning opportunity on the other teams. A Community of Practice! _ Build
Communities of Practice around around skills. However, people still belong to their
feature teams. _ Community experts now must bring everyone else up to speed in the
community. * Experts are not paid because they are so, but because they help others
become an expert too.<!-- --></li>
<!-- --></ul>
<!-- --><h4>Planning</h4>
<!-- --><ul>
<!-- --><li>Move from grand visions to tiny bites. _ Don&#x27;t make plans too detailed - it will
waste time and cause confusion. _ Key features are important to identify. _ Defer
low value ideas indefinitely. _ Think about the product deeply, not just at the beginning,
but all the time. _ Stay loose and ready to change plans during the project. _ Make
time and money budgets, producing the most valuable features first. Stop when the
clock runs out. _ Break two week sprints into two/three day stories. _ Larger stories
(often broken into technical tasks) are hard for business-side people to evaluate
until the end of the two-week sprint. _ Teams should choose how much work they can
get done. They know better and will feel more commitment/determination to see the
work through. _ Have planning sessions where features are presented one at a time.</li>
<!-- --><li>Don&#x27;t estimate individual pieces of work, look at the aggregate and decide how
much the team can do. _ &#x27;Yesterday&#x27;s Weather&#x27; - You&#x27;ll get as much done today as
you did yesterday. _ Estimates are risky - they want to be improved, compared. What
is achieved by estimating? _ Get started immediately, if a prediction of how long
things will take is needed, just count the things done. _ Stretch goals are destructive.
Teams will try and unconsciously hurry - forgotten tests, unclean code. _ Hurrying
introduces defects. _ Defects take longer to fix than they do to prevent. _ Estimates
focus on the cost of things rather than the value. _ If there is too much food don&#x27;t
eat it, therein lies obesity and lethargy. * In it for the whole project, staying
healthy is critical.</li>
<!-- --></ul>
<!-- --><h4>Building</h4>
<!-- --><ul>
<!-- --><li>Go through a complete product development cycle from concept to ready to ship (requirements,
design, coding and testing) in the one- or two-week cycles. _ Large, vague, sweeping
requirements must be broken into small, practical next steps. _ Strive for maximum
value with minimum effort. _ Features are either done or not done. There is no middle
ground. _ Eliminate the test-and-fix finish. They drag on forever. _ Software should
be free of defects <!-- --><strong>all</strong> the time. _ Design as you go. _ Too much and all features
won&#x27;t be completed. _ Too little and features will be hard to execute. * Manage through
observation. Tweak, observe, tweak again.<!-- --></li>
<!-- --></ul>
<!-- --><h4>Slicing in Parallel</h4>
<!-- --><ul>
<!-- --><li>Every feature needs a solid infrastructure, a &quot;foundation&quot;. _ If foundation is
built first, too much of it will be built. Resulting in fewer features. _ Building
foundations first inhibits features being shipped. This restricts value creation.</li>
<!-- --><li>Build features to be complete enough (a simple functional version). Do not start
by building each feature to its full glory. _ We still need to build <!-- --><strong>all</strong> the
features that are important, not just a few. _ Fill these features to as much capability
as time permits. _ Small versions of each necessary feature, with just enough foundation
to be solid is best. _ Having the best product at every moment, means we have the
best possible project when we decide to ship. * Don&#x27;t design an entire system upfront,
as we never know upfront what the system will be.<!-- --></li>
<!-- --></ul>
<!-- --><h4>Bug Free</h4>
<!-- --><ul>
<!-- --><li>Product is built up of a set of correctly working features. _ Defects amount to
negative features. _ Progress becomes uncertain. _ Eliminating defects as you go
provides clarity on whats done. _ Defect repair is an unknown time delay. _ Repair
as you go. _ Bugs are introduced when design evolves and when features are added
or enhanced. _ Continuous comprehensive testing is required to catch new bugs. _
Business-level Tests: Verify we have received what we asked for. _ WE must test everything.
This means more and better tests over time. _ Test burden grows over time. We need
to keep up with it. _ Acceptance Test-Driven Development: Expressing features in
terms of tests they must pass. _ Programmer Tests: Use TDD to ensure the code works
as expected. _ More tests makes the team go faster. _ It takes longer to find and
fix a problem that to prevent one in the first place. _ Design improvements must
keep up, like testing practices. _ Every change tends to break our current design.</li>
<!-- --><li>Design must be refactored. _ Deteriorating design costs us in the same way a lack
of tests do. _ We get slower unless the design remains fresh. * Testing and refactoring
are required to make feature-by-feature development possible.</li>
<!-- --></ul>
<!-- --><h4>Recap</h4>
<!-- --><ul>
<!-- --><li>Value is what we want. _ Features deliver value. _ Manage by looking at value,
not by dates/artifacts that don&#x27;t deliver value. _ Planning by feature is easy. _
Don&#x27;t estimate if possible. Using &#x27;Yesterday&#x27;s Weather&#x27; works best _ Build features
as small complete products every week. _ Products must always work correctly and
be well designed.</li>
<!-- --></ul></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{}},"page":"/posts/software-development-nature","query":{},"buildId":"5XjfA1Y6gVshClxRW5E3Q","assetPrefix":"/personal-site","nextExport":true,"autoExport":true,"isFallback":false,"scriptLoader":[]}</script></body></html>